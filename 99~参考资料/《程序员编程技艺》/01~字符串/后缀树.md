## 后缀树

### 1.1、后缀树的定义

后缀树（Suffix tree）是一种数据结构，能快速解决很多关于字符串的问题。后缀树的概念最早由 Weiner 于 1973 年提出，既而由 McCreight 在 1976 年和 Ukkonen 在 1992 年和 1995 年加以改进完善。

后缀，顾名思义，就是后面尾巴的意思。比如说给定一长度为 n 的字符串 S=S1S2..Si..Sn，和整数 i，1 <= i <= n，子串 SiSi+1...Sn 便都是字符串 S 的后缀。

以字符串 S=XMADAMYX 为例，它的长度为 8，所以 S[1..8], S[2..8], ... , S[8..8]都算 S 的后缀，我们一般还把空字串也算成后缀。这样，我们一共有如下后缀。对于后缀 S[i..n]，我们说这项后缀起始于 i。

S[1..8], XMADAMYX，也就是字符串本身，起始位置为 1  
 S[2..8], MADAMYX，起始位置为 2  
 S[3..8], ADAMYX，起始位置为 3  
 S[4..8], DAMYX，起始位置为 4  
 S[5..8], AMYX，起始位置为 5  
 S[6..8], MYX，起始位置为 6  
 S[7..8], YX，起始位置为 7  
 S[8..8], X，起始位置为 8  
空字串，记为$。

而后缀树，就是包含一则字符串所有后缀的压缩 Trie。把上面的后缀加入 Trie 后，我们得到下面的结构：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/3.gif)

仔细观察上图，我们可以看到不少值得压缩的地方。比如蓝框标注的分支都是独苗，没有必要用单独的节点同边表示。如果我们允许任意一条边里包含多个字 母，就可以把这种没有分叉的路径压缩到一条边。而另外每条边已经包含了足够的后缀信息，我们就不用再给节点标注字符串信息，只需要**在叶节点上标注上每项后缀的起始位置**。

于是我们得到下图：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/4.gif)

这样的结构丢失了某些后缀。比如后**缀 X 在上图中消失了**，因为它正好是字符串 XMADAMYX 的前缀。为了避免这种情况，我们也规定**每项后缀不能是其它后缀的前缀**。要解决这个问题其实挺简单，在**待处理的子串后加一个空字串**就行了。例如我们处理 XMADAMYX 前，先把 XMADAMYX 变为 XMADAMYX$，于是就得到 suffix tree--后缀树了，如下图所示：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/5.gif)

### 1.2、后缀树的应用

后缀树可以解决最长回文问题，那它和最长回文有什么关系呢？在此之前，我们得先知道两个简单概念：

- 最低共有祖先，**LCA**（Lowest Common Ancestor)，也就是任意两节点（多个也行）最长的共有前缀。比如下图中，节点 7 同节点 1 的共同祖先是节点 5 与节点 10，但最低共同祖先是 5。查找 LCA 的算法是 O(1)的复杂度，当然，代价是需要对后缀树做复杂度为 O(n)的预处理。

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/6.jpg)

- 广义后缀树(Generalized Suffix Tree)。传统的后缀树处理一坨单词的所有后缀。广义后缀树存储任意多个单词的所有后缀。例如下图是单词**XMADAMYX 与 XYMADAMX 的广义后缀 树**。注意我们需要区分不同单词的后缀，所以叶节点用不同的特殊符号与后缀位置配对。

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/7.gif)

有了上面的概念，本文引言中提出的查找最长回文问题就相对简单了。咱们来回顾下引言中提出的回文问题的具体描述：找出给定字符串里的最长回文。例如输入 XMADAMYX，则输出 MADAM。

思维的突破点在于考察回文的半径，而不是回文本身。所谓半径，就是回文对折后的字串。比如回文 MADAM 的半径为 MAD，半径长度为 3，半径的中心是字母 D。显然，最长回文必有最长半径，且两条半径相等。

还是以 MADAM 为例，以 D 为中心往左，我们得到半径 DAM；以 D 为中心向右，我们得到半径 DAM。二者肯定相等。因为 MADAM 已经是单词 XMADAMYX 里的最长回文，我们可以肯定从**D 往左数的字串 DAMX 与从 D 往右数的子串 DAMYX 共享最长前缀 DAM**。而这，正是解决回文问题的关键。现在我们有后缀树，怎么把从 D 向左数的字串 DAMX 变成后缀呢？

到这个地步，答案应该明显：**把单词 XMADAMYX 翻转（XMADAMYX=>XYMADAMX**，**DAMX**就变成后缀了**）**就行了。于是我们把寻找回文的问题转换成了寻找两坨后缀的**LCA**的问题。当然，我们还需要知道 到底查询那些后缀间的 LCA。很简单，给定字符串 S，如果最长回文的中心在 i，那从位置 i 向右数的后缀刚好是 S(i)，而向左数的字符串刚好是翻转 S 后得到的字符串 S‘的后缀 S'(n-i+1)。这里的 n 是字符串 S 的长度。

拿单词 XMADAMYX 来说，回文中心为 D，那么 D 向右的后缀**DAMYX**假设是 S(i)（当 N=8，i 从 1 开始计数，i=4 时，便是 S(4..8)）;而对于翻转后的单词 XYMADAMX 而言，回文中心 D 向右对应的后缀为**DAMX**，也就是 S'(N-i+1)(（N=8，i=4，便是 S‘（5..8）） 。此刻已经可以得出，它们共享最长前缀，即**LCA（DAMYX，DAMX）=DAM**。有了这套直观解释，算法自然呼之欲出:

1. 预处理后缀树，使得查询 LCA 的复杂度为 O(1)。这步的开销是 O(N)，N 是单词 S 的长度 ；

2. 对单词的每一位置 i(也就是从 0 到 N-1)，获取 LCA(S(i), S‘(N-i+1)) 以及 LCA(S(i+1), S’(n-i+1))。查找两次的原因是我们需要考虑奇数回文和偶数回文的情况。这步要考察每坨 i，所以复杂度是 O(N) ；

3. 找到最大的 LCA，我们也就得到了回文的中心 i 以及回文的半径长度，自然也就得到了最长回文。总的复杂度 O(n)。

i 为 4 时，LCA(4$, 5#)为 DAM，正好是最长半径。此外，创建后缀树为 O(n)的时间复杂度。
