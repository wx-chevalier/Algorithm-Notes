# Trie 树（字典树）

## 方法介绍

### 1.1、什么是 Trie 树

Trie 树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。

Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

它有 3 个基本性质：

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。

### 1.2、树的构建

咱们先来看一个问题：假如现在给你 10 万个长度不超过 10 的单词，对于每一个单词，我们要判断它出没出现过，如果出现了，求第一次出现在第几个位置。对于这个问题，我们该怎么解决呢？

如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是 O(n^2)。显然对于 10 万的范围难以接受。

换个思路想：

- 假设我要查询的单词是 abcd，那么在它前面的单词中，以 b，c，d，f 之类开头的显然不必考虑，而只要找以 a 开头的中是否存在 abcd 就可以了。
- 同样的，在以 a 开头中的单词中，我们只要考虑以 b 作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。

即如果现在有 b，abc，abd，bcd，abcd，efg，hii 这 6 个单词，我们可以构建一棵如下图所示的树：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/1.jpg)

如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。

那么，对于一个单词，只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。

这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度（在这个例子中，便是 10）。这就是一棵 trie 树。

我们可以看到，trie 树每一层的节点数是 26^i 级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数 × 单词长度。

### 1.3、查询

Trie 树是简单但实用的数据结构，通常用于实现字典查询。我们做即时响应用户输入的 AJAX 搜索框时，就是 Trie 开始。本质上，Trie 是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。

下面，再举一个例子。给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的 Trie：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/8/8.4/2.gif)

可以看出：

- 每条边对应一个字母。
- 每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。
- 单词 inn 与单词 int 有共同的前缀“in”, 因此他们共享左边的一条分支，root->i->in。同理，ate, age, adv, 和 ant 共享前缀"a"，所以他们共享从根节点到节点"a"的边。

查询操纵非常简单。比如要查找 int，顺着路径 i -> in -> int 就找到了。

搭建 Trie 的基本算法也很简单，无非是逐一把每则单词的每个字母插入 Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词 add，就有下面几步：

1. 考察前缀"a"，发现边 a 已经存在。于是顺着边 a 走到节点 a。
2. 考察剩下的字符串"dd"的前缀"d"，发现从节点 a 出发，已经有边 d 存在。于是顺着边 d 走到节点 ad
3. 考察最后一个字符"d"，这下从节点 ad 出发没有边 d 了，于是创建节点 ad 的子节点 add，并把边 ad->add 标记为 d。

## 问题实例

**1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，请给出思想，给出时间复杂度分析**

**提示**：用 trie 树统计每个词出现的次数，时间复杂度是 O(n\*le)（le 表示单词的平均长度），然后是找出出现最频繁的前 10 个词。当然，也可以用堆来实现，时间复杂度是 O(n\*lg10)。所以总的时间复杂度，是 O(n\*le)与 O(n\*lg10)中较大的哪一个。

**2、寻找热门查询**

**原题**：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是 1 千万，但是如果去除重复和，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的 10 个查询串，要求使用的内存不能超过 1G。

**提示**：利用 trie 树，关键字域存该查询串出现的次数，没有出现为 0。最后用 10 个元素的最小推来对出现频率进行排序。
