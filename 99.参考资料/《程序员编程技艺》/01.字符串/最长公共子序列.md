# 最长公共子序列

## 问题描述

什么是最长公共子序列呢?好比一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。

举个例子，如：有两条随机序列，如 1 3 4 5 5 ，and 2 4 5 5 7 6，则它们的最长公共子序列便是：4 5 5。

## 分析与解法

### 解法一

最容易想到的算法是穷举搜索法，即对 X 的每一个子序列，检查它是否也是 Y 的子序列，从而确定它是否为 X 和 Y 的公共子序列，并且在检查过程中选出最长的公共子序列。X 和 Y 的所有子序列都检查过后即可求出 X 和 Y 的最长公共子序列。X 的一个子序列相应于下标序列{1, 2, …, m}的一个子序列，因此，X 共有 2m 个不同子序列（Y 亦如此，如为 2^n），从而穷举搜索法需要指数时间（2^m \* 2^n）。

### 解法二

事实上，最长公共子序列问题也有最优子结构性质。

记：  
 Xi=﹤ x1，⋯，xi ﹥即 X 序列的前 i 个字符 (1≤i≤m)（前缀）

Yj=﹤ y1，⋯，yj ﹥即 Y 序列的前 j 个字符 (1≤j≤n)（前缀）

假定 Z=﹤ z1，⋯，zk ﹥ ∈LCS(X , Y) 。

- 若**xm=yn**（最后一个字符相同），则不难用反证法证明：该字符必是 X 与 Y 的任一最长公共子序列 Z（设长度为 k）的最后一个字符，即有 zk = xm = yn 且显然有 Zk-1∈LCS(Xm-1 , Yn-1)即 Z 的前缀**Zk-1 是 Xm-1 与 Yn-1 的最长公共子序列。**此时，问题化归成求 Xm-1 与 Yn-1 的 LCS（LCS(X , Y)的长度等于 LCS(Xm-1 , Yn-1)的长度加 1）。

- 若**xm≠yn**，则亦不难用反证法证明：要么 Z∈LCS(Xm-1, Y)，要么 Z∈LCS(X , Yn-1)。由于 zk≠xm 与 zk≠yn 其中至少有一个必成立，若 zk≠xm 则有 Z∈LCS(Xm-1 , Y)，类似的，若 zk≠yn 则有 Z∈LCS(X , Yn-1)。此时，问题化归成求 Xm-1 与 Y 的 LCS 及 X 与 Yn-1 的 LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}。

由于上述当**xm≠yn**的情况中，求 LCS(Xm-1 , Y)的长度与 LCS(X , Yn-1)的长度，这两个问题不是相互独立的：两者都需要求 LCS(Xm-1，Yn-1)的长度。另外两个序列的 LCS 中包含了两个序列的前缀的 LCS，故问题具有最优子结构性质考虑用动态规划法。

也就是说，解决这个 LCS 问题，你要求三个方面的东西：1、LCS(Xm-1，Yn-1)+1；2、LCS(Xm-1，Y)，LCS(X，Yn-1)；3、max{LCS(Xm-1, Y)，LCS(X, Yn-1)}。

#### 最长公共子序列的结构

最长公共子序列的结构有如下表示：

设序列 X=< x1, x2, …, xm >和 Y=< y1, y2, …, yn >的一个最长公共子序列 Z=< z1, z2, …, zk >，则：

1. 若 xm=yn，则 zk=xm=yn 且 Zk-1 是 Xm-1 和 Yn-1 的最长公共子序列；
2. 若 xm≠yn 且 zk≠xm ，则 Z 是 Xm-1 和 Y 的最长公共子序列；
3. 若 xm≠yn 且 zk≠yn ，则 Z 是 X 和 Yn-1 的最长公共子序列。  
   其中 Xm-1 = < x1, x2, …, xm-1 >，Yn-1 = < y1, y2, …, yn-1 >，Zk-1 = < z1, z2, …, zk-1 >。

#### 子问题的递归结构

由最长公共子序列问题的最优子结构性质可知，要找出 X=< x1, x2, …, xm >和 Y=< y1, y2, …, yn >的最长公共子序列，可按以下方式递归地进行：当 xm=yn 时，找出 Xm-1 和 Yn-1 的最长公共子序列，然后在其尾部加上 xm(=yn)即可得 X 和 Y 的一个最长公共子序列。当 xm≠yn 时，必须解两个子问题，即找出 Xm-1 和 Y 的一个最长公共子序列及 X 和 Yn-1 的一个最长公共子序列。这两个公共子序列中较长者即为 X 和 Y 的一个最长公共子序列。

由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算 X 和 Y 的最长公共子序列时，可能要计算出 X 和 Yn-1 及 Xm-1 和 Y 的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算 Xm-1 和 Yn-1 的最长公共子序列。

与矩阵连乘积最优计算次序问题类似，我们来建立子问题的最优值的递归关系。用 c[i,j]记录序列 Xi 和 Yj 的最长公共子序列的长度。其中 Xi=< x1, x2, …, xi >，Yj=< y1, y2, …, yj >。当 i=0 或 j=0 时，空序列是 Xi 和 Yj 的最长公共子序列，故 c[i,j]=0。其他情况下，由定理可建立递归关系如下：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/11/11.1.jpg)

#### 计算最优值

直接利用上节节末的递归式，我们将很容易就能写出一个计算 c[i,j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共只有 θ(m\*n)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。

计算最长公共子序列长度的动态规划算法 LCS_LENGTH(X,Y)以序列 X=< x1, x2, …, xm >和 Y=< y1, y2, …, yn >作为输入。输出两个数组 c[0..m ,0..n]和 b[1..m ,1..n]。其中 c[i,j]存储 Xi 与 Yj 的最长公共子序列的长度，b[i,j]记录指示 c[i,j]的值是由哪一个子问题的解达到的，这在构造最长公共子序列时要用到。最后，X 和 Y 的最长公共子序列的长度记录于 c[m,n]中。

```
Procedure LCS_LENGTH(X,Y);
begin
  m:=length[X];
  n:=length[Y];
  for i:=1 to m do c[i,0]:=0;
  for j:=1 to n do c[0,j]:=0;
  for i:=1 to m do
    for j:=1 to n do
      if x[i]=y[j] then
        begin
          c[i,j]:=c[i-1,j-1]+1;
          b[i,j]:="↖";
        end
      else if c[i-1,j]≥c[i,j-1] then
        begin
          c[i,j]:=c[i-1,j];
          b[i,j]:="↑";
        end
      else
        begin
          c[i,j]:=c[i,j-1];
          b[i,j]:="←"
        end;
  return(c,b);
end;
```

由算法 LCS_LENGTH 计算得到的数组 b 可用于快速构造序列 X=< x1, x2, …, xm >和 Y=< y1, y2, …, yn >的最长公共子序列。首先从 b[m,n]开始，沿着其中的箭头所指的方向在数组 b 中搜索。

- 当 b[i,j]中遇到"↖"时（_意味着 xi=yi 是 LCS 的一个元素_），表示 Xi 与 Yj 的最长公共子序列是由 Xi-1 与 Yj-1 的最长公共子序列在尾部加上 xi 得到的子序列；

- 当 b[i,j]中遇到"↑"时，表示 Xi 与 Yj 的最长公共子序列和 Xi-1 与 Yj 的最长公共子序列相同；

- 当 b[i,j]中遇到"←"时，表示 Xi 与 Yj 的最长公共子序列和 Xi 与 Yj-1 的最长公共子序列相同。

这种方法是按照反序来找 LCS 的每一个元素的。由于每个数组单元的计算耗费 Ο(1)时间，算法 LCS_LENGTH 耗时 Ο(mn)。

#### 构造最长公共子序列

下面的算法 LCS(b,X,i,j)实现根据 b 的内容打印出 Xi 与 Yj 的最长公共子序列。通过算法的调用 LCS(b,X,length[X],length[Y])，便可打印出序列 X 和 Y 的最长公共子序列。

```
Procedure LCS(b,X,i,j);
begin
  if i=0 or j=0 then return;
  if b[i,j]="↖" then
    begin
      LCS(b,X,i-1,j-1);
      print(x[i]); {打印x[i]}
    end
  else if b[i,j]="↑" then LCS(b,X,i-1,j)
                      else LCS(b,X,i,j-1);
end;
```

在算法 LCS 中，每一次的递归调用使 i 或 j 减 1，因此算法的计算时间为 O(m+n)。

例如，设所给的两个序列为 X=< A，B，C，B，D，A，B >和 Y=< B，D，C，A，B，A >。由算法 LCS_LENGTH 和 LCS 计算出的结果如下图所示：

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/The-Art-Of-Programming/images/11/11.2.jpg)

- 我来说明下此图（参考算法导论）\*。在序列 X={A，B，C，B，D，A，B}和 Y={B，D，C，A，B，A}上，由 LCS_LENGTH 计算出的表 c 和 b。第 i 行和第 j 列中的方块包含了 c[i，j]的值以及指向 b[i，j]的箭头。在 c[7,6]的项 4，表的右下角为 X 和 Y 的一个 LCS < B，C，B，A >的长度。对于 i，j>0，项 c[i，j]仅依赖于是否有 xi=yi，及项 c[i-1，j]和 c[i，j-1]的值，这几个项都在 c[i，j]之前计算。为了重构一个 LCS 的元素，从右下角开始跟踪 b[i，j]的箭头即可，这条路径标示为阴影，这条路径上的每一个“↖”对应于一个使 xi=yi 为一个 LCS 的成员的项（高亮标示）。  
  所以根据上述图所示的结果，程序将最终输出：“B C B A”。

#### 算法的改进

对于一个具体问题，按照一般的算法设计策略设计出的算法，往往在算法的时间和空间需求上还可以改进。这种改进，通常是利用具体问题的一些特殊性。

例如，在算法 LCS_LENGTH 和 LCS 中，可进一步将数组 b 省去。事实上，数组元素 c[i,j]的值仅由 c[i-1,j-1]，c[i-1,j]和 c[i,j-1]三个值之一确定，而数组元素 b[i,j]也只是用来指示 c[i,j]究竟由哪个值确定。因此，在算法 LCS 中，我们可以不借助于数组 b 而借助于数组 c 本身临时判断 c[i,j]的值是由 c[i-1,j-1]，c[i-1,j]和 c[i,j-1]中哪一个数值元素所确定，代价是 Ο(1)时间。既然 b 对于算法 LCS 不是必要的，那么算法 LCS_LENGTH 便不必保存它。这一来，可节省 θ(mn)的空间，而 LCS_LENGTH 和 LCS 所需要的时间分别仍然是 Ο(mn)和 Ο(m+n)。不过，由于数组 c 仍需要 Ο(mn)的空间，因此这里所作的改进，只是在空间复杂性的常数因子上的改进。

另外，如果只需要计算最长公共子序列的长度，则算法的空间需求还可大大减少。事实上，在计算 c[i,j]时，只用到数组 c 的第 i 行和第 i-1 行。因此，只要用 2 行的数组空间就可以计算出最长公共子序列的长度。更进一步的分析还可将空间需求减至 min(m, n)。

#### 编码实现 LCS 问题

动态规划的一个计算最长公共子序列的方法如下，以两个序列 X、Y 为例子：

设有二维数组 f[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有：

f[1][1] = same(1,1)  
 f[i][j] = max{f[i − 1][j − 1] +same(i,j), f[i − 1][j] ,f[i][j − 1]}

其中，same(a,b)当 X 的第 a 位与 Y 的第 b 位完全相同时为“1”，否则为“0”。

此时，f[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。

该算法的空间、时间复杂度均为 O(n2)，经过优化后，空间复杂度可为 O(n)，时间复杂度为 O(nlogn)。

## 举一反三

1、最长递增子序列 LIS（Longest Increasing Subsequence）

给定一个长度为 N 的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为 6 的数组 A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为 4。

分析：其实此 LIS 问题可以转换成最长公子序列问题，为什么呢？

- 原数组为 A {5， 6， 7， 1， 2， 8}
- 排序后：A‘{1， 2， 5， 6， 7， 8}

因为，原数组 A 的子序列顺序保持不变，而且排序后 A‘本身就是递增的，这样，就保证了两序列的最长公共子序列的递增特性。如此，若想求数组 A 的最长递增子序列，其实就是求数组 A 与它的排序数组 A‘的最长公共子序列。

此外，本题也可以使用动态规划来求解，读者可以继续思考。
