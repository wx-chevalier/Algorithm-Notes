# 寻找最小的 k 个数

## 题目描述

输入 n 个整数，输出其中最小的 k 个。

## 分析与解法

### 解法一

要求一个序列中最小的 k 个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的 k 个数。

至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为`n*logn`），然后再遍历序列中前 k 个元素输出即可。因此，总的时间复杂度：`O（n * log n)+O(k)=O（n * log n）`。

### 解法二

咱们再进一步想想，题目没有要求最小的 k 个数有序，也没要求最后 n-k 个数有序。既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：

1、遍历 n 个数，把最先遍历到的 k 个数存入到大小为 k 的数组中，假设它们即是最小的 k 个数；  
2、对这 k 个数，利用选择或交换排序找到这 k 个元素中的最大值 kmax（找最大值需要遍历这 k 个数，时间复杂度为`O（k）`）；  
3、继续遍历剩余 n-k 个数。假设每一次遍历到的新的元素的值为 x，把 x 与 kmax 比较：如果`x < kmax` ，用 x 替换 kmax，并回到第二步重新找出 k 个元素的数组中最大元素 kmax‘；如果`x >= kmax`，则继续遍历不更新数组。

每次遍历，更新或不更新数组的所用的时间为`O（k）`或`O（0）`。故整趟下来，时间复杂度为`n*O（k）=O（n*k）`。

### 解法三

更好的办法是维护容量为 k 的最大堆，原理跟解法二的方法相似：

- 1、用容量为 k 的最大堆存储最先遍历到的 k 个数，同样假设它们即是最小的 k 个数；
- 2、堆中元素是有序的，令 k1<k2<...<kmax（kmax 设为最大堆中的最大元素）
- 3、遍历剩余 n-k 个数。假设每一次遍历到的新的元素的值为 x，把 x 与堆顶元素 kmax 比较：如果`x < kmax`，用 x 替换 kmax，然后更新堆（用时 logk）；否则不更新堆。

这样下来，总的时间复杂度:`O（k+（n-k）*logk）=O（n*logk）`。此方法得益于堆中进行查找和更新的时间复杂度均为：`O(logk)`（若使用解法二：在数组中找出最大元素，时间复杂度：`O（k））`。

### 解法四

在《数据结构与算法分析--c 语言描述》一书，第 7 章第 7.7.6 节中，阐述了一种在平均情况下，时间复杂度为`O（N）`的快速选择算法。如下述文字：

- 选取 S 中一个元素作为枢纽元 v，将集合 S-{v}分割成 S1 和 S2，就像快速排序那样
- 如果 k <= |S1|，那么第 k 个最小元素必然在 S1 中。在这种情况下，返回 QuickSelect(S1, k)。
- 如果 k = 1 + |S1|，那么枢纽元素就是第 k 个最小元素，即找到，直接返回它。
- 否则，这第 k 个最小元素就在 S2 中，即 S2 中的第（k - |S1| - 1）个最小元素，我们递归调用并返回 QuickSelect(S2, k - |S1| - 1)。

此算法的平均运行时间为 O(n)。

示例代码如下：

```cpp
//QuickSelect 将第k小的元素放在 a[k-1]
void QuickSelect( int a[], int k, int left, int right )
{
    int i, j;
    int pivot;

    if( left + cutoff <= right )
    {
        pivot = median3( a, left, right );
        //取三数中值作为枢纽元，可以很大程度上避免最坏情况
        i = left; j = right - 1;
        for( ; ; )
        {
            while( a[ ++i ] < pivot ){ }
            while( a[ --j ] > pivot ){ }
            if( i < j )
                swap( &a[ i ], &a[ j ] );
            else
                break;
        }
        //重置枢纽元
        swap( &a[ i ], &a[ right - 1 ] );

        if( k <= i )
            QuickSelect( a, k, left, i - 1 );
        else if( k > i + 1 )
            QuickSelect( a, k, i + 1, right );
    }
    else
        InsertSort( a + left, right - left + 1 );
}

```

这个快速选择 SELECT 算法，类似快速排序的划分方法。N 个数存储在数组 S 中，再从数组中选取“中位数的中位数”作为枢纽元 X，把数组划分为 Sa 和 Sb 俩部分，Sa<=X<=Sb，如果要查找的 k 个元素小于 Sa 的元素个数，则返回 Sa 中较小的 k 个元素，否则返回 Sa 中所有元素+Sb 中小的 k-|Sa|个元素，这种解法在平均情况下能做到`O(n)`的复杂度。

更进一步，《算法导论》第 9 章第 9.3 节介绍了一个最坏情况下亦为 O(n)时间的 SELECT 算法，有兴趣的读者可以参看。

## 举一反三

1、谷歌面试题：输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前 k 个数怎么做？

分析：

     “假设两个整数数组为A和B，各有N个元素，任意两个数的和组成的数组C有N^2个元素。
       那么可以把这些和看成N个有序数列：
              A[1]+B[1] <= A[1]+B[2] <= A[1]+B[3] <=…
              A[2]+B[1] <= A[2]+B[2] <= A[2]+B[3] <=…
              …
             A[N]+B[1] <= A[N]+B[2] <= A[N]+B[3] <=…
        问题转变成，在这N^2个有序数列里，找到前k小的元素”

2、有两个序列 A 和 B,A=(a1,a2,...,ak),B=(b1,b2,...,bk)，A 和 B 都按升序排列。对于 1<=i,j<=k，求 k 个最小的（ai+bj）。要求算法尽量高效。

3、给定一个数列 a1,a2,a3,...,an 和 m 个三元组表示的查询，对于每个查询(i，j，k)，输出 ai，ai+1，...，aj 的升序排列中第 k 个数。
